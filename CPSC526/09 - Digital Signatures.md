### Overview
 - Cryptographic mechanism for verifying integrity and authenticity of digital data (message)
 - Signature is computed from message
	 - Signature is specific to the message and the sender
	 - Signature can only be generated by the sender
 - Signature is kept or transmitted together with the message
 - Upon receipt, signature is verified to match the received message
	 - Anyone, including 3rd parties, are able to verify that the signature matches the message and the sender
 - Verification of a signature prevents tampering and forgery
	 - Successful verification ensures the data was not modified
	 - and that the data was sent by a particular sender
 - Signature is typically a fixed sized block of data (4096 bits) regardless of message size
 - Digital signatures are constructed using public cryptography

### Digital Signatures vs Message Authentication Codes
 - Digital signatures are similar to MACs
	 - Both have fixed size
	 - Both offer integrity: Receiver can verify integrity of message
	 - Both offer authentication Receiver knows the message came from sender
 - There are some important differences too
	 - Signatures provide non-repudiation
		 - 3rd party can verify a signature was created by sender
		 - Sender cannot deny signing the message
	 - MAC requires a shared secret key, DS requires public/private key pair

### Digital Signature Scheme
 - `Gen()` - Creates a pair of keys:
	 - `sk` (signing key) used to create signatures over messages, kept secret
	 - `vk` (verification key) used to verify signatures, made available to everyone
 - `Sign(key, message)` - Produces a signature under a given key
 - `Ver(key, message)` - Checks a signature using the associated key
 - Similar to public-key cipher, but inverted
	 - Encryption: Anyone can close padlock, only the keyholder can open it
	 - Signatures: Anyone can open padlock, only the keyholder can close it
 - When Alice is sending a message to Bob:
	 - Alice uses Alice's private key to sign the message
	 - Bob uses Alice's public key to verify the message
 - Alice and Bob should use different pairs of keys for signing and encrypting

### RSA Signatures
 - RSA signatures can be implemented using RSA cipher + cryptographic hash function
 - `Gen()`:
	 - Verification key: Same as GenRSA public key
	 - Signing key: Same as GenRSA private key
 - `Sign(sk, m)`:
	 - `sig = EncRSA(H(m), sk)`
	 - First compute the hash of the message, and then encrypt the hash using the sk
 - `Ver(vk,m,sig)`:
	 - Compare `H(m) = Dec-RSA(sig,vk)`
	 - Re-compute hash of message, compare it to decrypted signature
 - Note: Cannot use RSA-OAEP as the signatures would not be different every time

### Attack Models on Digital Signatures
 - Attackers abilities:
	 - Key-Only Attack: Attacker has access only to public verification key
	 - Known-Message Attack: Attacker is given access to many messages + corresponding signatures
	 - Adaptive-Chosen-Message Attack: Attacker can choose any messages to sign
 - Digital signature scheme security levels:
	 - Total Break: Attacker learns the signing key
	 - Universal Forgery: Attacker is able to sign any message, of anybody's choosing
	 - Selective Forgery: Attacker is able to sign a particular message selected by attacker
	 - Existential Forgery: Attacker is able to find at least one previously unused message + signature pair, although the message may be useless to the attacker
 - The strongest security is resistant to existential forgery under adaptive-chosen-message attack 
	 - RSA signatures can have this

### Real Signatures vs Digital Signatures
**Real Signatures**:
 - Experts needed to validate signatures
 - Modify document -> Signature unchanged
 - Multi-page document usually has signature on last page, removing/adding pages is difficult to detect
 - Plausible signature forgeries are easy to produce

**Digital Signatures**:
 - Anyone can validate signatures
 - Modify document -> signature invalidated
 - Any document changes are detected, whether it is a single- or multi-page document
 - There are no plausible forgeries; signature either matches or it does not
 - However, using a stolen signing key is impossible to detect

### Authenticated DHKE
**Problem**:
 - As long as Alice and Bob do not make mistakes, DHKE is secure from passive attacks (eavesdropping)
 - What if the attacker is able to tamper with the communications?
	 - Delete, insert, modify, record & replay messages
 - There are many pieces of software/hardware between Alice and Bob
	 - Hubs, routers, switches, firewalls, etc
	 - Each device & piece of wire could be attacked
 - Mallory can insert herself between Alice & Bob to perform a Man-In-The-Middle Attack (MITM)
	 - Alice thinks that she is getting Bob's public key, but is actually Mallory's, impersonate Bob
 - With the DHKE, Attacker has shared one key with Alice and another with Bob
	 - Alice and Bob think they are sharing a key with each other

**Authenticated DHKE**:
 - To prevent MITM, we attach digital signatures to all communications during DHKE
	 - Alice signs everything with her private key `ska`
	 - Bob signs everything with his private key `skb`
 - Alice and Bob can now verify that MITM did not tamper with the exchange
![[Authenticated_DHKE.png]]
 - This prevents replay attacks as Bob has included `g^a` in his signed message
	 - Implies that Bob signed it after the receipt
	 - Foils replay, as `g^a` is different every time
 - Basis of challenge-response authentication
	 - A nonce (number used once) is sent as a challenge to the communication partner
	 - The response includes crypto done on the nonce
 - DHKE is used even though we have RSA in order to achieve *forward secrecy*

**Forward Secrecy**:
 - Compromise of long-term secret key does not compromise past session keys
	 - If Eve finds Alice's and/or Bob's private keys, she would not be able to decrypt past conversations
 - Communications based on DHKE have this property if each session uses different exponents, as the calculated key K will be different every time
 - Watch for this in secure communication products you might want to use

### Key Generation in Python
 - https://cryptography.io/en/latest/hazmat/primitives/asymmetric/rsa/

**Generating a 512-bit key pair, displayed in PEM format**:
```python
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization
private_key = rsa.generate_private_key( public_exponent=65537, key_size=2048 )
pem_priv = private_key.private_bytes(
   encoding=serialization.Encoding.PEM,
   format=serialization.PrivateFormat.TraditionalOpenSSL,
   encryption_algorithm=serialization.NoEncryption() # Can encrypt the key
)
public_key = private_key.public_key()
pem_pub = public_key.public_bytes(
   encoding=serialization.Encoding.PEM,
   format=serialization.PublicFormat.SubjectPublicKeyInfo
)
print(pem_priv.decode("ascii"))
print(pem_pub.decode("ascii"))
```
