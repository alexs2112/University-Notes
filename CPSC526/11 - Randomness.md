### Fundamental Problem
 - Computers are very predictable
	 - Machine operations are deterministic
	 - Will do exactly the same steps at boot
	 - A room of identical computers will finish booting at same time
 - Without any user interaction, there will be no difference
 - Randomly generated numbers will always be the same
	 - Unless you introduce something from the environment

### Random Numbers & Security
 - Modern cryptography relies on random numbers
 - Random cryptographic keys (in hybrid crypto -> random symmetric key)
 - Random IVs (for CTR mode)
 - Random nonces (challenge/response protocols, DHKE)
 - Unique identifier

**Types of Randomness**:
 - True Randomness:
	 - Happens in nature, randomness from good sources (dice)
	 - Unpredictable from all information
		 - Cannot guess previous nor future numbers
		 - To an information theoretic attacker (infinite computation power)
		 - Next number is completely independent from all previous numbers
	 - Independent randomness
 - Pseudo Randomness
	 - Numbers that look random but may fail some statistical tests
		 - Can be predicted with the right information
	 - Numbers are not independent from other generated numbers

**Pseudo Random Number Generators (PRNGs)**:
 - PRNGs generate a stream of pseudo random numbers
 - Using a seed and an algorithm
	 - The seed should be unique (typically)
	 - The same seed generates the same stream
 - Two types:
	 - Not cryptographically suitable: PRNG
		 - (`drand48()`, `rand()`, etc)
	 - Cryptographically suitable, CSPRNG
		 - Cryptographically secure/strong/suitable PRNG

**CSPRNG**:
 - Cryptographically suitable means that a computationally bounded adversary cannot distinguish a PRNG's random stream and a true random stream
 - We can test PRNGs output randomness using statistical tests
 - They hold up under other attacks
	 - Eg. when attacker learns some information about the state

**PRNG State**:
 - The seed is used to randomize the initial state
 - The state is then used to generate random numbers
 - If you know the state, you can generate the sequence of random numbers
 - Important for CSPRNG: Random numbers do not reveal the state

**CSPRNG Properties**:
 - Prediction Resistant:
	 - Looking at previous numbers, you cannot guess the next ones
	 - Even if attacker learned the state, he would not be able to predict future numbers, except maybe for a few of them
 - Rollback Resistant:
	 - Even if the attacker learns the current state, he cannot learn previous numbers generated by the stream leading up to the current state
	 - Similar to forward security

**Why is Rollback Resistance Useful?**:
 - Suppose PRNG is bad, or implementation has a bug
 - Typical use for crypto is to generate a key, then generate IV
 - IV is not encrypted when sent
 - Attacker could observe IV and learn key from it

**Non-Cryptographically Suitable PRNGs**:
 - Functions like `rand()` are not cryptographically secure
	 - eg. linear congruence generators like `y=(x*p) % n`
	 - Given enough samples, you can start predicting the next ones
	 - or figure out the seed, as it is usually an earlier timestamp: `srand(time(NULL))`
 - If the seed is predictable, then the stream is also predictable
	 - This applies to CSPRNGs too
	 - eg. using current time as seed to CSPRNG makes it insecure (by misuing it)
 - Even CSPRNGs need a true random seed to work properly
	 - With a true random seed, they produce cryptographically suitable random streams

### Stream Ciphers & Randomness
 - Some stream ciphers are mimicking OTP by generating an infinite key using a CSPRNG
 - For example: AES-CTR is using a key and a random initial counter `x`
	 - Creates a pseudorandom stream: `E(key,x), E(key,x+1), E(key,x+2), ...`
	 - This stream is then XOR-ed with the plaintext to produce ciphertext
 - AES-CTR is vulnerable if the seed becomes known
	 - AES is broken
 - This stream is not rollback resistant if you know the key

**What Needs Randomness**:
 - Sometimes we need unguessable/unpredictable values
	 - One-time pads, encryption keys, random challenges
 - Other times we just need unique values
	 - Salts, challenges, nonces, IVs, identifiers
 - When using random numbers for super important things, we need truly random values
	 - Eg. use coin flips to create long-lived high-stakes keys for banks
 - Unique probably does not need to be cryptographically suitable
	 - Note: Randomness based on time not guaranteed to be unique
	 - ie. time is a function every other computer on the planet is trying to match
 - To be safe, just use cryptographically secure randomness
	 - Only one disadvantage: CSPRNGs are typically much slower than regular PRNGs

### Cryptographically Suitable Randomness
**Sources of Cryptographically Suitable Randomness**:
 - Computer is too deterministic, need to monitor something of the outside environment
 - Observations of physical phenomena:
	 - Dice rolling, coin flipping, radioactive decay
 - Some hardware events:
	 - Time between keystrokes
	 - Mouse movements
	 - Other I/O events
 - Idea: Hard for external observers to measure
 - Network packet arrival times: Likely not a good source of randomness
	 - Anything that can be measured, predicted, or influenced, is unusable for crypto
	 - Including current time, local port of a socket, serial number on MAC address
 - If Eve can predict the next random bit that Alice chooses even slightly better than by random guessing, it is a bad source of randomness

**Randomness for Linux**:
 - Linux effectively has one random device: `/dev/urandom`
	 - Uses CSPRNG to generate a stream
	 - Much slower than `rand()`
 - Seeded with true randomness from hardware events
	 - Randomness from keyboard and mouse and other HW activities that are human driven
	 - Randomness is fed into the "entropy pool" and mixed
	 - Reading from `/dev/urandom` provides hash output from that pool
 - Servers may not get useful events for randomness
	 - Racks of identical servers running identical workloads won't differ (much)

**Randomness Extraction**:
 - Suppose you have a coin that flips heads 2/3 of the time and tails 1/3 of the time
	 - Can you use this to get a random number? (50/50 chance to be 0)
 - Answer 1:
	 - Flip biased coin twice
	 - If both flips are heads (4/9) return 1
	 - If both flips are different (2/9 + 2/9 = 4/9) return 0
	 - Otherwise, repeat
 - Answer 2:
	 - Flip biased coin twice
	 - Return 1 if results were head then tail (2/9)
	 - Return 0 if results were tail then head (2/9)
	 - Otherwise, repeat (5/9)
	 - Much less efficient, but would work for any (even unknown) bias
 - This is relevant for real-life biased sources that need to be turned into a random number
	 - Example: Mouse clicks, left click is far more common than right click

**Example of Bad Randomness**:
 - `Dual_EC_PRNG`
	 - Dual Elliptic Curve Deterministic Random Bit Generator
	 - PRNG based on elliptic curves, but with no proven security
	 - Relies on two parameters, P and Q
	 - The parameters were chosen without explanation
 - `Dual_EC_DRBG`
	 - Criticized by experts for its poor design shortly (<1 year) after publication
	 - Much slower than existing simpler secure alternatives
	 - Even bias in the output bits (0.1%)
		 - Failed the most basic test of a useful PRNG
	 - Known that for any P, there could be a specific Q backdoor
		 - The backdoor would allow attacker to determine internal state from observing 32 bytes of output
		 - Future outputs of the RNG would be then predictable
 - Clear that `Dual_EC_DRBG` was a terrible PRNG and no one wanted to use it
	 - RSA was pushing it super hard, people were curious
	 - NSA paid RSA a lot of money and had NIST standardize it
	 - RSA accepted 10 million dollars from NSA in a secret deal
	 - Used P and Q that the NSA recommended
		 - The algorithm is otherwise good if there are good P and Q chosen
	 - Then pushed it as a NIST standard, put into many other products (including TLS HTTPS)
	 - NSA could then break security with a wide-spread backdoored PRNG
	 - Took 6-7 years for RSA to tell people to stop using their NSA code

**Magic Numbers**:
 - Many implementations of crypto rely on specific magic numbers to work
	 - All such numbers should be chosen with clear justification
 - Nothing-up-my-sleeve numbers are constructed with documented methods, to make sure they cannot be suspected to have hidden properties
 - The explanation should have low Kolmogorov complexity (short description)

**Good CSPRNG - HMAC_DRBG**:
 - State is a key `k` from seed and `v` of data
 - Uses HMAC to generate data and to update state
 - Prediction & rollback resistance
 - No funny numbers
 - NIST Special Publication 800-90A Revision 1 (with Dual_EC_DRBG removes)
 - Multiple papers published with it, no errors have been found

### UUID: Universally Unique Identifier (RFC4122)
 - Imagine you need to generate a unique name for some resource
	 - eg. to store something in a distributed database
	 - eg. to store something in a distributed file system
	 - and you need to keep the unique name for a very long time
	 - and you need to generate many unique names every second
	 - and you need to do this *without a centralized service*
 - UUIDs are 128-bit numbers, usually formatted as hyphen separated hexadecimal
 - `12345678-1234-1234-1234-123456789012`
 - Three common ways to generate them:
	 - Fully random (version 4)
	 - Name based (version 3 and 5)
	 - Time & host based (version 1)
 - More versions might be coming in the future
	 - Proposed v6, v7, v8 - more time & host based UUIDs

**UUIDv4 - Random**:
 - Use CSPRNG to generate a 128 bit value (16 bytes)
	 - If you do not need standard compliance, you are done
	 - You can use this as an ID
 - To make it conform to RFC4122:
	 - Set 6 of the bits to predefined values, to indicate UUIDv4
	 - Format integer as hex
	 - Add a few hyphens
```python
import os
b = os.urandom(16)     # CSPRNG
i = int.from_bytes(b)  # convert to binary
i &= ~(0xc000 << 48)   # adjust 2 bit variant (set bits 73,74 to 0)
i |= 0x8000 << 48      #   according to rfc 4122 (sets one of the bits to 1)
i &= ~(0xf000 << 64)   # adjust 4 bit version  (set bits 88-92 to 0)
i |= 4 << 76           #   according to rfc 4122 (sets those bits to 1, version number) 
h = f"{i:032x}"        # convert to hex
# add dashes
id = h[:8]+"-"+h[8:12]+"-"+h[12:16]+"-"+h[16:20]+"-"+h[20:]
# ready to print
print(f"{id}")
# uuid='d63d2636-4889-44b7-8bc8-f234e4f8575f'
# The 4 leading the 3rd section is the version
```
 - Contains 122 bits of random bits
 - Collisions are possible (birthday attack)
 - To get 50% collision chance, we would need to generate 2^(122/2) UUIDs
	 - If we were only storing UUIDs, we would need 2^61 * 16 bytes = ~36 exabytes of storage
 - To get 10^(-15) chance of collisions, we would need to generate ~10^11 UUIDs
	 - Or ~3000 UUIDs/sec for 1 year

**UUIDv3 and UUIDv5 - Name-Derived**:
 - Basic idea is similar to v4, but instead of using a random number:
	 - Make a unique textual name of the resource - as long as you ike
	 - Hash it using MD5 (v3) or SHA-1 (v5)
 - Fix 6 of the bits (to make it RFC4122 compliant)
	 - To indicate v3 or v5
 - Format as hex to add hyphens
 - UUID v3 and v5 are deterministic, but still unique provided the resource name is unique
```python
from hashlib import sha1
name = b'''Pavol's computer in Math Science, ICT 123, running Ubuntu 22.04 LTS,
on Dell Optiplex 9800 purchased in October 1995, Calgary, Canada, Earth'''
b = sha1(name).digest()[:16]
i = int.from_bytes(b)
i &= ~(0xc000 << 48)   # adjust 2 bit variant
i |= 0x8000 << 48      #   according to rfc 4122
i &= ~(0xf000 << 64)   # adjust 5 bit version
i |= 5 << 76           #   according to rfc 4122
h = f"{i:032x}"        # convert to hex
# add dashes
id = h[:8]+"-"+h[8:12]+"-"+h[12:16]+"-"+h[16:20]+"-"+h[20:]
print(f"{id}")
# uuid='8866b88e-c72f-5dcd-9897-dbf4c3b10a0c'
# The 5 leading the 3rd section is the version
```

**UUIDv1 - Time & Host Based**:
 - Uses a timestamp, a 60 bit count of 100 ns intervals since 15 Oct 1582
	 - and the MAC address of the computer that generated the UUID
 - Reveals the host that generates it, but guarantees it to be unique
 - The reason for the strange shape of the UUID
	 - `XXXXXXXX-YYYY-ZZZZ-VVVV-WWWWWWWWWWWW`

|     | field       | bits | value                                       |
| --- | ----------- | ---- | ------------------------------------------- |
| X   | `time_low`  | 32   | digits of the timestamp                     |
| Y   | `time_mid`  | 16   | next few digits of the timestamp            |
| Z   | `ver`       | 4    | 0b0001 version v1                           |
| Z   | `time_high` | 12   | remaining digits of the timestamp           |
| V   | `var`       | 2    | 0b10 variant                                |
| V   | `clock_seq` | 14   | counts how many times the time was adjusted |
| W   | `node`      | 48   | MAC address of the computer                 |

```python
import uuid
for i in range(10):
    print(uuid.uuid1())
# cd534bd0-d5e8-11ee-922e-00505694e94d
# cd534d92-d5e8-11ee-922e-00505694e94d
# cd534e82-d5e8-11ee-922e-00505694e94d
# cd534f04-d5e8-11ee-922e-00505694e94d
# cd534fcc-d5e8-11ee-922e-00505694e94d
# cd53504e-d5e8-11ee-922e-00505694e94d
# cd5350da-d5e8-11ee-922e-00505694e94d
# cd535184-d5e8-11ee-922e-00505694e94d
# cd535210-d5e8-11ee-922e-00505694e94d
# cd535288-d5e8-11ee-922e-00505694e94d
```
